datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  createdAt     DateTime       @default(now())
  emailAccounts EmailAccount[]
  messages      Message[]
  preference    UserPreference?
}

model EmailAccount {
  id           String   @id @default(uuid())
  provider     String
  // Stable ID from the OAuth provider (e.g. Google sub / providerAccountId).
  // Nullable for mocked/manual accounts.
  providerAccountId String?
  emailAddress String
  userId       String
  createdAt    DateTime @default(now())
  accessToken  String?
  refreshToken String?
  expiresAt    DateTime?
  scope        String?
  tokenType    String?
  lastSyncedAt DateTime?
  lastSyncError String?
  // Gmail History API cursor for true delta sync (stringified numeric historyId).
  gmailHistoryId String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages Message[]

  // Allow multiple accounts per provider per user (e.g. multiple Gmail mailboxes),
  // while preventing duplicates.
  @@unique([userId, provider, emailAddress])
  // Prevent the same OAuth account being connected multiple times (across all users).
  @@unique([provider, providerAccountId])
}

model Message {
  id                 String   @id @default(uuid())
  userId             String
  emailAccountId     String
  provider           String
  providerMessageId  String
  threadId           String?
  subject            String?
  fromAddress        String?
  toAddress          String?
  date               DateTime?
  snippet            String?
  labels             Json?
  isRead             Boolean  @default(false)
  isArchived         Boolean  @default(false)
  syncedAt           DateTime @default(now())
  createdAt          DateTime @default(now())

  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  emailAccount  EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)

  // Provider IDs are only unique within a mailbox/account.
  @@unique([emailAccountId, providerMessageId])
  @@index([userId, provider])
}

model UserPreference {
  id          String   @id @default(uuid())
  userId      String   @unique
  savedViews  Json     @default("[]")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}



